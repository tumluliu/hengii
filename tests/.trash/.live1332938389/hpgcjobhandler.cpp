/*
 * =====================================================================================
 *
 *       Filename:  hpgcjobhandler.cpp
 *
 *    Description:  The class skeleton is generated by thrift compiler. All the service
 *  			  	interface are implemented here.
 *
 *        Version:  0.6
 *        Created:  2012年03月23日 11时47分00秒
 *       Revision:  none
 *       Compiler:  gcc
 *
 *         Author:  Liu Lu(), nudtlliu@gmail.com
 *   Organization:  
 *
 * =====================================================================================
 */
#include <sys/time.h>
#include "hpgcjobhandler.h"

int HpgcJobHandler::findEmptyPoolSlot() {
	sessionItr = sessionPool.begin();
	while (sessionItr != sessionPool.end()) {
		if ((sessionItr->second).isAvailable())
			return sessionItr->first;
		sessionItr++;
	}
	return -1;
}

int HpgcJobHandler::generateSessionId() {
	struct timeval now;
	int id;
	do {
		gettimeofday(&now, NULL);
		srand(now.tv_usec);
		id = rand();
	} while (sessionPool.count(id));	
	return id;
}

HpgcJobHandler::HpgcJobHandler() {
	for (int i = 0; i < SESSION_POOL_SIZE; i++) {
		int id = generateSessionId();
		Session s(id);
		sessionPool.insert(map<int, Session>::value_type(id, s));
	}
}

int32_t HpgcJobHandler::start_single_job(const Job& job) {
	cout << "start single job, which is a just a grammer candy of start job flow" << endl;
	JobFlow flow;
	flow.job_count = 1;
	flow.jobs.push_back(job);
	return start(flow); 
}

int32_t HpgcJobHandler::start(const JobFlow& flow) {
	cout << "Start processing " << PROJECT_NAME << " job flow..." << endl;
	cout << "number of jobs in this flow: " << flow.job_count << endl;
	int idleSessionId;
	do {
		idleSessionId = findEmptyPoolSlot();
	} while (idleSessionId == -1);
	Session *activeSession =  &sessionPool[idleSessionId];
	activeSession->init(flow);
	activeSession->setAvailable(false);
	if (activeSession->createJobThreads() != 0) {
		cout << "Create job thread failed. Job flow processing is terminated." << endl;
		activeSession->finalize();
		activeSession->setAvailable(true);
	}
	return static_cast<int32_t>(idleSessionId);
}

void HpgcJobHandler::pause(const int32_t client_ticket) {
	string sig = "suspend";
	for (int i = 0; i < sessionPool[client_ticket].getJobCount(); i++) {
		JobTracker tracker = sessionPool[client_ticket].getJobTrackerAt(i);
		if (tracker.getStatus() == "R")
			pbs_sigjob(tracker.getConnection(), 
					const_cast<char*>(tracker.getId().c_str()), 
					const_cast<char*>(sig.c_str()), 0);
		else if (tracker.getStatus() == "C")
			cout << "job " << tracker.getUserJob().id<< "has done!"<<endl;
		else
			pbs_holdjob(tracker.getConnection(), const_cast<char*>(tracker.getId().c_str()), 0, 0);
	}
	cout << "pause_flow" << endl;
}

void HpgcJobHandler::resume(const int32_t client_ticket) {
	string sig = "resume";
	for (int i = 0; i < sessionPool[client_ticket].getJobCount(); i++) {
		JobTracker tracker = sessionPool[client_ticket].getJobTrackerAt(i);
		if (tracker.getStatus() == "S") {
			pbs_sigjob(tracker.getConnection(), 
					const_cast<char*>(tracker.getId().c_str()), 
					const_cast<char *>(sig.c_str()), 0);
		}		
		else if (tracker.getStatus() == "H")
			pbs_rlsjob(tracker.getConnection(), const_cast<char*>(tracker.getId().c_str()), 0, 0);	 
		else
			cout << "job " << tracker.getUserJob().id << " hasn't suspended!" << endl;
	}
	cout << "resume_flow" << endl;
}

void HpgcJobHandler::cancel(const int32_t client_ticket) {
	for (int i = 0; i < sessionPool[client_ticket].getJobCount(); i++) {	
		JobTracker tracker = sessionPool[client_ticket].getJobTrackerAt(i);
		if (tracker.getStatus() != "C") {
			pbs_deljob(tracker.getConnection(), 
					const_cast<char*>((tracker.getId()).c_str()), 0);
		}
		else
			cout << "job " << tracker.getUserJob().id << " has done!" << endl;
	}
	cout << "cancel_flow" << endl;
}

void HpgcJobHandler::get_status(Result& _return, const int32_t client_ticket) {
	string msgToClient;
	cout << "get job flow status..." << endl;
	if (sessionPool.count(client_ticket) == 0) {
		_return.status = JOB_NOT_EXIST;
		_return.message = "get status error, job id not exist";
		_return.progress = 0.0;
		cout << "get status error, job id not exist" << endl;
	}
	else {
		_return.status = JOB_STATUS_FINISHED;
		for (int i = 0; i < sessionPool[client_ticket].getJobCount(); i++) {
			JobTracker tracker = sessionPool[client_ticket].getJobTrackerAt(i);
			if (tracker.getThreadState() != THREAD_STATE_FINISHED_SUCCESS) {
				_return.status = JOB_STATUS_UNFINISHED;
				break;
			}
		}
		cout << "the job status is: " << _return.status << endl;
		if (_return.status == JOB_STATUS_FINISHED) { 
			for (int i = 0; i < sessionPool[client_ticket].getJobCount(); i++) {
				JobTracker tracker = sessionPool[client_ticket].getJobTrackerAt(i);
				msgToClient += tracker.getResult();
			}
			Utility::log(RUN_LOG_FILE, msgToClient);
			cout << "The result sent to client is:" << endl;
			cout << msgToClient << endl;
			_return.message = msgToClient;
			// The progress getting function has not been implemented yet!
			_return.progress = 0.618;
			sessionPool[client_ticket].setAvailable(true);
		}
		else
			_return.message = "";
		//	cout<<"HPGC flow finished."<<endl;
		//	!!!! the finalize of the current active session should not be placed only here
		//	it should be invoked when the job or jobflow is really finished. !!!!
		//	by Liu Lu
		//	2012/3/19
		sessionPool[client_ticket].finalize();
	}
	//  pthread_cond_destroy(&waitingCond);
}

