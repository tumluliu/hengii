// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "hpgcjobserver_h.h"

#define PARAM_SIZE 1024

using namespace HPGC::HiGIS::Server;

class HpgcJobHandler : virtual public HpgcJobIf {
private:
	JobflowParam Jobflowparam[16]; 
	map<int32_t,int> client;
public:
  HpgcJobHandler() {
   for (int i=0;i<16;i++)
		Jobflowparam[i].available=0;
  }

  int32_t start(const Job& job) {
    // Your implementation goes here
    printf("start\n");
  }

  int32_t start_flow(const JobFlow& flow) ;

  void pause(const Job& job, const int32_t client_id) {
		int i = job.id;
		int Con;
		int j = client[client_id];
		char* pbsjob_id;
		char* sig = "suspend";
		Con=Jobflowparam[j].Threadparam[i].connect;
		pbsjob_id=const_cast<char*>((Jobflowparam[j].Threadparam[i].pbsjob_id).c_str()) ;
//		cout<<"connect="<<Con<<endl;
//		cout<<"pbsjob_id="<<pbsjob_id<<endl;
		if(*(Jobflowparam[j].Threadparam[i].pbs_state)=='R')
			pbs_sigjob(Con,pbsjob_id,sig,0);
		   
		else if(*(Jobflowparam[j].Threadparam[i].pbs_state)=='C')
			cout<<"job has done!"<<endl;
		else
			pbs_holdjob(Con,pbsjob_id,0,0);
   	printf("pause\n");
  }

  void pause_flow(const JobFlow& flow, const int32_t client_id) {
		int Con;
		char* pbsjob_id;
		char* sig = "suspend";
		int j = client[client_id];
		
//		cout<<"client_id="<<j<<endl;
		for(int i=0; i<flow.job_count; i++)
		{
			Con=Jobflowparam[j].Threadparam[i].connect;
			pbsjob_id=const_cast<char*>((Jobflowparam[j].Threadparam[i].pbsjob_id).c_str()) ;
//			cout<<"connect="<<Con<<endl;
//			cout<<"pbsjob_id="<<pbsjob_id<<endl;
			if(*(Jobflowparam[j].Threadparam[i].pbs_state)=='R')
				pbs_sigjob(Con,pbsjob_id,sig,0);
			  
			else if(*(Jobflowparam[j].Threadparam[i].pbs_state)=='C')
				cout<<"job "<<Jobflowparam[j].Threadparam[i].job.id<< "has done!"<<endl;
			else
				pbs_holdjob(Con,pbsjob_id,0,0);
		}
		printf("pause_flow\n");
  }

  void resume(const Job& job, const int32_t client_id) {
	   int i = job.id;
		int j = client[client_id];
		int Con;
		char* pbsjob_id;
		char* sig = "resume";
		Con=Jobflowparam[j].Threadparam[i].connect;
		pbsjob_id=const_cast<char*>((Jobflowparam[j].Threadparam[i].pbsjob_id).c_str()) ;
//		cout<<"connect="<<Con<<endl;
//		cout<<"pbsjob_id="<<pbsjob_id<<endl;
		if(*(Jobflowparam[j].Threadparam[i].pbs_state)=='S')
			pbs_sigjob(Con,pbsjob_id,sig,0);
		
		else if(*(Jobflowparam[j].Threadparam[i].pbs_state)=='H')
			pbs_rlsjob(Con,pbsjob_id,0,0);	   
		else
			cout<<"job hasn't suspend!"<<endl;
		printf("resume\n");
  }

  void resume_flow(const JobFlow& flow, const int32_t client_id) {
		int Con;
		char* pbsjob_id;
		char* sig = "resume";
		int j = client[client_id];
		for(int i=0; i<flow.job_count; i++)
		{
			Con=Jobflowparam[j].Threadparam[i].connect;
			pbsjob_id=const_cast<char*>((Jobflowparam[j].Threadparam[i].pbsjob_id).c_str()) ;
//			cout<<"connect="<<Con<<endl;
//			cout<<"pbsjob_id="<<pbsjob_id<<endl;
			if(*(Jobflowparam[j].Threadparam[i].pbs_state)=='S')
			{
				
				pbs_sigjob(Con,pbsjob_id,sig,0);
			}		
			else if(*(Jobflowparam[j].Threadparam[i].pbs_state)=='H')
				pbs_rlsjob(Con,pbsjob_id,0,0);	 
			else
				cout<<"job "<<Jobflowparam[j].Threadparam[i].job.id<<" hasn't suspend!"<<endl;
		}
   	printf("resume_flow\n");
  }

  void cancel(const Job& job, const int32_t client_id) {
   	int i = job.id;
		int j = client[client_id];
		int Con;
		char* pbsjob_id;
		if(*(Jobflowparam[j].Threadparam[i].pbs_state)!='C')
		{
			Con=Jobflowparam[j].Threadparam[i].connect;
			pbsjob_id=const_cast<char*>((Jobflowparam[j].Threadparam[i].pbsjob_id).c_str()) ;
//			cout<<"connect="<<Con<<endl;
//			cout<<"pbsjob_id="<<pbsjob_id<<endl;
			pbs_deljob(Con,pbsjob_id,0);
		}
		else
			cout<<"job has done!"<<endl;
   	printf("cancel\n");
  }

  void cancel_flow(const JobFlow& flow, const int32_t client_id) {
		int Con;
		char* pbsjob_id;
		int j = client[client_id];
		for(int i=0; i<flow.job_count; i++)
		{	
			if(*(Jobflowparam[j].Threadparam[i].pbs_state)!='C')
			{
				Con=Jobflowparam[j].Threadparam[i].connect;
				pbsjob_id=const_cast<char*>((Jobflowparam[j].Threadparam[i].pbsjob_id).c_str()) ;
//				cout<<"connect="<<Con<<endl;
//				cout<<"pbsjob_id="<<pbsjob_id<<endl;
				pbs_deljob(Con,pbsjob_id,0);
			}
			else
				cout<<"job "<<Jobflowparam[j].Threadparam[i].job.id<<" has done!"<<endl;
		}
	   printf("cancel_flow\n");
  }

  void get_job_status(Result& _return, const Job& job, const int32_t client_id) {
	   int i = job.id;
		int j = client[client_id];
		if(Jobflowparam[j].Threadparam[i].thread_state==0)
		{
			_return.status=0;
			_return.message="";
		}
		else
		{
			_return.status = 1;
			_return.message = Jobflowparam[j].Threadparam[i].result;
		}
	    printf("get_job_status\n");
  }

  void get_flow_status(Result& _return, const JobFlow& flow, const int32_t client_id) {
  		string senddata;
	//	cout<<"HPGC flow finished."<<endl;
		_return.status = 1;
		int j = client[client_id];
		for(int i=0;i<flow.job_count;i++)
		{
			if(Jobflowparam[j].Threadparam[i].thread_state==0)
			{
				_return.status=0;
				break;
			}
		}
//		cout<<"the job status is: "<<_return.status<<endl;
		if(_return.status==1)
		{
			for(int i=0;i<flow.job_count;i++)
			{
				senddata+=Jobflowparam[j].Threadparam[i].result;
			}
			char Path[PARAM_SIZE];
			memset(Path, '\0', sizeof(Path) ); 
			getcwd(Path,sizeof(Path));
			string run_path=Path;
 			run_path+="/run.log";
			ofstream outfile(run_path.c_str(),ios::out);
			if (!outfile)
				cout<<"open run.log error!"<<endl;
			outfile<<senddata<<endl;
			outfile.close();
			cout<<"The senddata is:"<<senddata<<endl;
			_return.message=senddata;
			Jobflowparam[j].available = 1;
		}
		else
			_return.message="";
		//	cout<<"HPGC flow finished."<<endl;
		pthread_attr_destroy(&Jobflowparam[j].attr);
		pthread_mutex_destroy(&Jobflowparam[j].state_mutex_global);
		//  pthread_cond_destroy(&state_threshold_cv_global);
		//  pthread_exit(NULL);
  }

  double get_job_progress(const Job& job, const int32_t client_id) {
    // Your implementation goes here
    printf("get_job_progress\n");
  }

  double get_flow_progress(const JobFlow& flow, const int32_t client_id) {
    // Your implementation goes here
    printf("get_flow_progress\n");
  }

};

int32_t HpgcJobHandler::start_flow(const JobFlow& flow) {
	// Your implementation goes here
	cout<<"Start running HPGC jobs..."<<endl;
	cout<<"number of jobs in this flow: "<<flow.job_count<<endl;
	int firstAvailable ;
	do
	{
		firstAvailable = findAvailableResource(Jobflowparam);
	}
	while(firstAvailable == -1);
	JobflowParam *Jobflow_Param =  &Jobflowparam[firstAvailable];
	pthread_mutex_init(&Jobflow_Param->state_mutex_global, NULL);
	pthread_cond_init (&Jobflow_Param->state_threshold_cv_global, NULL);
	pthread_attr_init(&Jobflow_Param->attr);
	pthread_attr_setdetachstate(&Jobflow_Param->attr, PTHREAD_CREATE_JOINABLE);
	if (Jobflow_Param->state_global.empty()==0)
	{
//		cout<<"is not empty"<<endl;
		Jobflow_Param->state_global.clear();
	}		

	for(int i=0;i<flow.job_count;i++)
	{
		Jobflow_Param->state_global.push_back(flow.jobs[i].parent_count);
	}
	ThreadParam threadparam[flow.job_count];
	if (Jobflow_Param->Threadparam.empty()==0)
	{
//		cout<<"is not empty"<<endl;
		Jobflow_Param->Threadparam.clear();
	}	
	for(int i=0;i<flow.job_count;i++)
	{
		threadparam[i].state_global_iter=Jobflow_Param->state_global.begin();
		threadparam[i].state_mutex_GLOBAL=&Jobflow_Param->state_mutex_global;
		threadparam[i].state_threshold_cv_GLOBAL=&Jobflow_Param->state_threshold_cv_global;
		threadparam[i].job=flow.jobs[i];
		threadparam[i].thread_state=0;
		threadparam[i].pbs_state="N";
		threadparam[i].result="";
		threadparam[i].pbsjob_id="";
		threadparam[i].connect=0;
	//		pbsjob_id[i]=const_cast<char*>((threadparam[i].pbsjob_id).c_str()) ;
	//		threadparam[i].connect = &connect[i];
					
		Jobflow_Param->Threadparam.push_back(threadparam[i]);
	//cout<<"threadparam[i].state"<<Threadparam[i].state<<endl;
	}
	Jobflow_Param->available=9;
	int i=0;
	for (vector<ThreadParam>::size_type ix=0; ix!=flow.job_count; ++ix)
	{			
		pthread_create(&Jobflow_Param->threadId_GLOBAL[i], &Jobflow_Param->attr, threadFunction, &(Jobflow_Param->Threadparam[ix]));
		i++;		
	}
	struct timeval tpstart;
	int32_t client_id;
	do{
	gettimeofday(&tpstart,NULL);
	srand(tpstart.tv_usec);
	client_id=rand();
	}while(client.count(client_id));	
	client.insert(map<int32_t,int>::value_type(client_id,firstAvailable));
	return client_id;
}


int main(int argc, char **argv) {
  int port = 9090;
  int workerCount = 16; 
//	init_daemon();
  shared_ptr<HpgcJobHandler> handler(new HpgcJobHandler());
  shared_ptr<TProcessor> processor(new HpgcJobProcessor(handler));
  shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());
  shared_ptr<ThreadManager> threadManager = ThreadManager::newSimpleThreadManager(workerCount);
  shared_ptr<PosixThreadFactory> threadFactory = shared_ptr<PosixThreadFactory>(new PosixThreadFactory());
  threadManager->threadFactory(threadFactory);
  threadManager->start();
  TNonblockingServer server(processor, protocolFactory, port, threadManager);
//  TNonblockingServer server(processor,protocolFactory,port);
  cout<<"Starting hpgcserver..."<<endl;
  server.serve();
  return 0;
}
