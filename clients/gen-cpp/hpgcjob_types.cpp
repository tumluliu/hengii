/**
 * Autogenerated by Thrift Compiler (0.7.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 */
#include "hpgcjob_types.h"

namespace HPGC { namespace HiGIS { namespace Server {

int _kParallelEnvValues[] = {
  ParallelEnv::MPI,
  ParallelEnv::OPENMP,
  ParallelEnv::CUDA,
  ParallelEnv::MAPREDUCE
};
const char* _kParallelEnvNames[] = {
  "MPI",
  "OPENMP",
  "CUDA",
  "MAPREDUCE"
};
const std::map<int, const char*> _ParallelEnv_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kParallelEnvValues, _kParallelEnvNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kJobStatusValues[] = {
  JobStatus::FINISHED,
  JobStatus::RUNNING,
  JobStatus::WAITING_FOR_SUBMIT,
  JobStatus::QUEUING,
  JobStatus::EXIT_WITH_ERROR
};
const char* _kJobStatusNames[] = {
  "FINISHED",
  "RUNNING",
  "WAITING_FOR_SUBMIT",
  "QUEUING",
  "EXIT_WITH_ERROR"
};
const std::map<int, const char*> _JobStatus_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(5, _kJobStatusValues, _kJobStatusNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

const char* JobFlowStatus::ascii_fingerprint = "87C2618D316F4CF12649B129BA0E78C6";
const uint8_t JobFlowStatus::binary_fingerprint[16] = {0x87,0xC2,0x61,0x8D,0x31,0x6F,0x4C,0xF1,0x26,0x49,0xB1,0x29,0xBA,0x0E,0x78,0xC6};

uint32_t JobFlowStatus::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->job_status_list.clear();
            uint32_t _size0;
            ::apache::thrift::protocol::TType _etype3;
            iprot->readListBegin(_etype3, _size0);
            this->job_status_list.resize(_size0);
            uint32_t _i4;
            for (_i4 = 0; _i4 < _size0; ++_i4)
            {
              int32_t ecast5;
              xfer += iprot->readI32(ecast5);
              this->job_status_list[_i4] = (JobStatus::type)ecast5;
            }
            iprot->readListEnd();
          }
          this->__isset.job_status_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t JobFlowStatus::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("JobFlowStatus");
  xfer += oprot->writeFieldBegin("job_status_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->job_status_list.size()));
    std::vector<JobStatus::type> ::const_iterator _iter6;
    for (_iter6 = this->job_status_list.begin(); _iter6 != this->job_status_list.end(); ++_iter6)
    {
      xfer += oprot->writeI32((int32_t)(*_iter6));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const char* Context::ascii_fingerprint = "B089C846F881A6F18D64AA924E6643EF";
const uint8_t Context::binary_fingerprint[16] = {0xB0,0x89,0xC8,0x46,0xF8,0x81,0xA6,0xF1,0x8D,0x64,0xAA,0x92,0x4E,0x66,0x43,0xEF};

uint32_t Context::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast7;
          xfer += iprot->readI32(ecast7);
          this->parallel_env = (ParallelEnv::type)ecast7;
          this->__isset.parallel_env = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->options.clear();
            uint32_t _size8;
            ::apache::thrift::protocol::TType _ktype9;
            ::apache::thrift::protocol::TType _vtype10;
            iprot->readMapBegin(_ktype9, _vtype10, _size8);
            uint32_t _i12;
            for (_i12 = 0; _i12 < _size8; ++_i12)
            {
              std::string _key13;
              xfer += iprot->readString(_key13);
              std::string& _val14 = this->options[_key13];
              xfer += iprot->readString(_val14);
            }
            iprot->readMapEnd();
          }
          this->__isset.options = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Context::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Context");
  xfer += oprot->writeFieldBegin("parallel_env", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->parallel_env);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("options", ::apache::thrift::protocol::T_MAP, 2);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->options.size()));
    std::map<std::string, std::string> ::const_iterator _iter15;
    for (_iter15 = this->options.begin(); _iter15 != this->options.end(); ++_iter15)
    {
      xfer += oprot->writeString(_iter15->first);
      xfer += oprot->writeString(_iter15->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const char* Job::ascii_fingerprint = "AAB3E23D0CA517D25ADE9C7E5242001C";
const uint8_t Job::binary_fingerprint[16] = {0xAA,0xB3,0xE2,0x3D,0x0C,0xA5,0x17,0xD2,0x5A,0xDE,0x9C,0x7E,0x52,0x42,0x00,0x1C};

uint32_t Job::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->parents.clear();
            uint32_t _size16;
            ::apache::thrift::protocol::TType _etype19;
            iprot->readListBegin(_etype19, _size16);
            this->parents.resize(_size16);
            uint32_t _i20;
            for (_i20 = 0; _i20 < _size16; ++_i20)
            {
              xfer += iprot->readI32(this->parents[_i20]);
            }
            iprot->readListEnd();
          }
          this->__isset.parents = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->parent_count);
          this->__isset.parent_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->children.clear();
            uint32_t _size21;
            ::apache::thrift::protocol::TType _etype24;
            iprot->readListBegin(_etype24, _size21);
            this->children.resize(_size21);
            uint32_t _i25;
            for (_i25 = 0; _i25 < _size21; ++_i25)
            {
              xfer += iprot->readI32(this->children[_i25]);
            }
            iprot->readListEnd();
          }
          this->__isset.children = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->child_count);
          this->__isset.child_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->app_id);
          this->__isset.app_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->app_options.clear();
            uint32_t _size26;
            ::apache::thrift::protocol::TType _ktype27;
            ::apache::thrift::protocol::TType _vtype28;
            iprot->readMapBegin(_ktype27, _vtype28, _size26);
            uint32_t _i30;
            for (_i30 = 0; _i30 < _size26; ++_i30)
            {
              std::string _key31;
              xfer += iprot->readString(_key31);
              std::string& _val32 = this->app_options[_key31];
              xfer += iprot->readString(_val32);
            }
            iprot->readMapEnd();
          }
          this->__isset.app_options = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->runtime_context.read(iprot);
          this->__isset.runtime_context = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->app_uri);
          this->__isset.app_uri = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Job::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Job");
  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->id);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("parents", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->parents.size()));
    std::vector<int32_t> ::const_iterator _iter33;
    for (_iter33 = this->parents.begin(); _iter33 != this->parents.end(); ++_iter33)
    {
      xfer += oprot->writeI32((*_iter33));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("parent_count", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->parent_count);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("children", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->children.size()));
    std::vector<int32_t> ::const_iterator _iter34;
    for (_iter34 = this->children.begin(); _iter34 != this->children.end(); ++_iter34)
    {
      xfer += oprot->writeI32((*_iter34));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("child_count", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->child_count);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("app_id", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->app_id);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("app_options", ::apache::thrift::protocol::T_MAP, 7);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->app_options.size()));
    std::map<std::string, std::string> ::const_iterator _iter35;
    for (_iter35 = this->app_options.begin(); _iter35 != this->app_options.end(); ++_iter35)
    {
      xfer += oprot->writeString(_iter35->first);
      xfer += oprot->writeString(_iter35->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("runtime_context", ::apache::thrift::protocol::T_STRUCT, 8);
  xfer += this->runtime_context.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("app_uri", ::apache::thrift::protocol::T_STRING, 9);
  xfer += oprot->writeString(this->app_uri);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const char* Result::ascii_fingerprint = "5F560B229F9DF5A7A7AD8075A81A830F";
const uint8_t Result::binary_fingerprint[16] = {0x5F,0x56,0x0B,0x22,0x9F,0x9D,0xF5,0xA7,0xA7,0xAD,0x80,0x75,0xA8,0x1A,0x83,0x0F};

uint32_t Result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->progress);
          this->__isset.progress = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Result::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Result");
  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("progress", ::apache::thrift::protocol::T_DOUBLE, 3);
  xfer += oprot->writeDouble(this->progress);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const char* JobFlow::ascii_fingerprint = "E4017BBEAB7C3A641127D8FB9488B421";
const uint8_t JobFlow::binary_fingerprint[16] = {0xE4,0x01,0x7B,0xBE,0xAB,0x7C,0x3A,0x64,0x11,0x27,0xD8,0xFB,0x94,0x88,0xB4,0x21};

uint32_t JobFlow::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->jobs.clear();
            uint32_t _size36;
            ::apache::thrift::protocol::TType _etype39;
            iprot->readListBegin(_etype39, _size36);
            this->jobs.resize(_size36);
            uint32_t _i40;
            for (_i40 = 0; _i40 < _size36; ++_i40)
            {
              xfer += this->jobs[_i40].read(iprot);
            }
            iprot->readListEnd();
          }
          this->__isset.jobs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->job_count);
          this->__isset.job_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t JobFlow::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("JobFlow");
  xfer += oprot->writeFieldBegin("jobs", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->jobs.size()));
    std::vector<Job> ::const_iterator _iter41;
    for (_iter41 = this->jobs.begin(); _iter41 != this->jobs.end(); ++_iter41)
    {
      xfer += (*_iter41).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("job_count", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->job_count);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const char* HpgcJobException::ascii_fingerprint = "3368C2F81F2FEF71F11EDACDB2A3ECEF";
const uint8_t HpgcJobException::binary_fingerprint[16] = {0x33,0x68,0xC2,0xF8,0x1F,0x2F,0xEF,0x71,0xF1,0x1E,0xDA,0xCD,0xB2,0xA3,0xEC,0xEF};

uint32_t HpgcJobException::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->app_id);
          this->__isset.app_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HpgcJobException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("HpgcJobException");
  xfer += oprot->writeFieldBegin("app_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->app_id);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

}}} // namespace
