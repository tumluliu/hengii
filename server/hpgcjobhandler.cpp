/*
 * =====================================================================================
 *
 *       Filename:  hpgcjobhandler.cpp
 *
 *    Description:  The class skeleton is generated by thrift compiler. All the service
 *  			  	interface are implemented here.
 *
 *        Version:  0.7
 *        Created:  2012年03月23日 11时47分00秒
 *       Revision:  none
 *       Compiler:  gcc
 *
 *         Author:  Liu Lu(), nudtlliu@gmail.com
 *   Organization:  
 *
 * =====================================================================================
 */
#include <sys/time.h>
#include <sstream>
#include "hpgcjobhandler.h"
#include "logger.h"

int64_t HpgcJobHandler::findEmptyPoolSlot() {
	requestItr = requestPool.begin();
	while (requestItr != requestPool.end()) {
		if ((requestItr->second).isAvailable())
			return requestItr->first;
		requestItr++;
	}
	return -1;
}

int64_t HpgcJobHandler::generateRequestId() {
	int64_t id;
	int64_t prefix;

	srand(time(0));
	do {
		prefix = time(0) * 1000;
		id = prefix + rand() % 1000;
	} while(requestPool.count(id) > 0);
	return id;
}

HpgcJobHandler::HpgcJobHandler() {
	for (int i = 0; i < REQUEST_POOL_SIZE; i++) {
		addRequest();
	}
}

void HpgcJobHandler::addRequest() {
	int64_t id = generateRequestId();
	Request s(id);
	requestPool.insert(map<int64_t, Request>::value_type(id, s));
}

int64_t HpgcJobHandler::start_single_job(const Job& job, const std::string& user_id) {
	Logger::log(STDOUT, DEBUG, ENGINE, "start single job, which is a just a grammer candy of start job flow");
	JobFlow flow;
	flow.job_count = 1;
	flow.jobs.push_back(job);
	return start(flow, user_id); 
}

int64_t HpgcJobHandler::start(const JobFlow& flow, const std::string& user_id) {
	Logger::log(STDOUT, INFO, ENGINE, "Start processing " + PROJECT_NAME + " job flow...");
	stringstream msg;
	msg << "number of jobs in this flow: " << flow.job_count;
	Logger::log(STDOUT, DEBUG, ENGINE, msg.str());
	int64_t idleRequestId;
	do {
		idleRequestId = findEmptyPoolSlot();
	} while (idleRequestId == -1);
	Request *activeRequest =  &requestPool[idleRequestId];
	activeRequest->setAvailable(false);
	activeRequest->init(flow);
	activeRequest->setUserId(user_id);
	if (activeRequest->createJobThreads() != 0) {
		Logger::log(STDOUT, ERROR, ENGINE, "Create job thread failed. Job flow processing is terminated.");
		activeRequest->finalize();
	}
	return static_cast<int64_t>(idleRequestId);
}

void HpgcJobHandler::pause(const int64_t client_ticket) {
	string sig = "suspend";
	for (int i = 0; i < requestPool[client_ticket].getJobCount(); i++) {
		JobTracker tracker = requestPool[client_ticket].getJobTrackerAt(i);
		if (tracker.getStatus() == JobStatus::RUNNING)
			pbs_sigjob(tracker.getConnection(), 
					const_cast<char*>(tracker.getId().c_str()), 
					const_cast<char*>(sig.c_str()), 0);
		else if (tracker.getStatus() == JobStatus::FINISHED) {
			stringstream msg;
			msg << "job " << tracker.getUserJob().id << "is already done.";
			Logger::log(STDOUT, INFO, ENGINE, msg.str());
		}
		else
			pbs_holdjob(tracker.getConnection(), const_cast<char*>(tracker.getId().c_str()), 0, 0);
	}
	Logger::log(STDOUT, INFO, ENGINE, "job flow paused.");
}

void HpgcJobHandler::resume(const int64_t client_ticket) {
	string sig = "resume";
	for (int i = 0; i < requestPool[client_ticket].getJobCount(); i++) {
		JobTracker tracker = requestPool[client_ticket].getJobTrackerAt(i);
		if (tracker.getStatus() == JobStatus::PAUSED) {
			pbs_sigjob(tracker.getConnection(), 
					const_cast<char*>(tracker.getId().c_str()), 
					const_cast<char *>(sig.c_str()), 0);
		}		
		else {
			stringstream msg;
			msg << "job " << tracker.getUserJob().id << " hasn't been suspended!";
			Logger::log(STDOUT, WARN, ENGINE, msg.str());
		}
	}
	Logger::log(STDOUT, INFO, ENGINE, "job flow resumed.");
}

void HpgcJobHandler::cancel(const int64_t client_ticket) {
	for (int i = 0; i < requestPool[client_ticket].getJobCount(); i++) {	
		JobTracker tracker = requestPool[client_ticket].getJobTrackerAt(i);
		if (tracker.getStatus() != JobStatus::RUNNING && tracker.getStatus() != JobStatus::FAILED ) {
			pbs_deljob(tracker.getConnection(), 
					const_cast<char*>((tracker.getId()).c_str()), 0);
		}
		else {
			stringstream msg;
			msg << "job " << tracker.getUserJob().id << "is already done.";
			Logger::log(STDOUT, INFO, ENGINE, msg.str());
		}
	}
	Logger::log(STDOUT, INFO, ENGINE, "job flow canceled.");
}

void HpgcJobHandler::get_status(Result& _return, const int64_t client_ticket) {
	if (requestPool.count(client_ticket) == 0) {
		_return.flow_status = Status::NOT_EXIST;
		_return.message = "get status error, job id not exist";
		Logger::log(STDOUT, ERROR, ENGINE, _return.message);
	}
	else {
		_return.flow_status = Status::FINISHED;
		_return.message = "";

		for (int i = 0; i < requestPool[client_ticket].getJobCount(); i++) {
			JobTracker tracker = requestPool[client_ticket].getJobTrackerAt(i);
			JobResult jr;
			jr.message = tracker.getResult();
			jr.status = tracker.getStatus();
			if (jr.status == JobStatus::FAILED) {
				_return.flow_status = Status::FAILED;
			}	
			if (jr.status != JobStatus::FAILED && jr.status != JobStatus::FINISHED) {
				_return.flow_status = Status::RUNNING;
			}
			_return.job_result_list.push_back(jr);

			if (_return.flow_status == Status::FINISHED) {
				Severity lvl = _return.flow_status == Status::FINISHED ? INFO : ERROR;
				Logger::log(STDOUT, lvl, ENGINE, "The result sent to client is: ");
				Logger::log(LOG_FILE, lvl, APPLICATION, "message of job: " + jr.message);	
				Logger::log(STDOUT, lvl, APPLICATION, "message of job: " + jr.message);	
			}
		}

		if (_return.flow_status == Status::FAILED || _return.flow_status == Status::FINISHED ) {
			requestPool[client_ticket].setAvailable(true);
			requestPool[client_ticket].finalize();
			// !!!! There are some big problems here!!!!!!
			requestPool.erase(client_ticket);
			addRequest();
			Logger::log(STDOUT, INFO, ENGINE, "request resource released. ");
		}

		//	cout<<"HPGC flow finished."<<endl;
		//	!!!! the finalize of the current active request should not be placed only here
		//	it should be invoked when the job or jobflow is really finished. !!!!
		//	by Liu Lu
		//	2012/3/19
	}
	//  pthread_cond_destroy(&waitingCond);
}

void HpgcJobHandler::get_my_requests(std::vector<int64_t> & _return, const std::string& user_id) {
	// warning!!!
	// Not implemente yet. The clients now rely on database for fast implementation
}

void HpgcJobHandler::get_all_requests(std::vector<int64_t> & _return) {
	// warning!!!
	// Not implemente yet. The clients now rely on database for fast implementation
}
