/*
 * =====================================================================================
 *
 *       Filename:  hpgcjobhandler.cpp
 *
 *    Description:  The class skeleton is generated by thrift compiler. All the service
 *  			  	interface are implemented here.
 *
 *        Version:  0.6
 *        Created:  2012年03月23日 11时47分00秒
 *       Revision:  none
 *       Compiler:  gcc
 *
 *         Author:  Liu Lu(), nudtlliu@gmail.com
 *   Organization:  
 *
 * =====================================================================================
 */
#include <sys/time.h>
#include "hpgcjobhandler.h"
#include "logger.h"

int HpgcJobHandler::findEmptyPoolSlot() {
	sessionItr = sessionPool.begin();
	while (sessionItr != sessionPool.end()) {
		if ((sessionItr->second).isAvailable())
			return sessionItr->first;
		sessionItr++;
	}
	return -1;
}

int HpgcJobHandler::generateSessionId() {
	struct timeval now;
	int id;
	do {
		gettimeofday(&now, NULL);
		srand(now.tv_usec);
		id = rand();
	} while (sessionPool.count(id));	
	return id;
}

HpgcJobHandler::HpgcJobHandler() {
	for (int i = 0; i < SESSION_POOL_SIZE; i++) {
		int id = generateSessionId();
		Session s(id);
		sessionPool.insert(map<int, Session>::value_type(id, s));
	}
}

int32_t HpgcJobHandler::start_single_job(const Job& job) {
	cout << "start single job, which is a just a grammer candy of start job flow" << endl;
	JobFlow flow;
	flow.job_count = 1;
	flow.jobs.push_back(job);
	return start(flow); 
}

int32_t HpgcJobHandler::start(const JobFlow& flow) {
	cout << "Start processing " << PROJECT_NAME << " job flow..." << endl;
	cout << "number of jobs in this flow: " << flow.job_count << endl;
	int idleSessionId;
	do {
		idleSessionId = findEmptyPoolSlot();
	} while (idleSessionId == -1);
	Session *activeSession =  &sessionPool[idleSessionId];
	activeSession->init(flow);
	activeSession->setAvailable(false);
	if (activeSession->createJobThreads() != 0) {
		cout << "Create job thread failed. Job flow processing is terminated." << endl;
		activeSession->finalize();
		activeSession->setAvailable(true);
	}
	return static_cast<int32_t>(idleSessionId);
}

void HpgcJobHandler::pause(const int32_t client_ticket) {
	string sig = "suspend";
	for (int i = 0; i < sessionPool[client_ticket].getJobCount(); i++) {
		JobTracker tracker = sessionPool[client_ticket].getJobTrackerAt(i);
		if (tracker.getStatus() == JobStatus::RUNNING)
			pbs_sigjob(tracker.getConnection(), 
					const_cast<char*>(tracker.getId().c_str()), 
					const_cast<char*>(sig.c_str()), 0);
		else if (tracker.getStatus() == JobStatus::FINISHED)
			cout << "job " << tracker.getUserJob().id<< "has done!"<<endl;
		else
			pbs_holdjob(tracker.getConnection(), const_cast<char*>(tracker.getId().c_str()), 0, 0);
	}
	cout << "pause_flow" << endl;
}

void HpgcJobHandler::resume(const int32_t client_ticket) {
	string sig = "resume";
	for (int i = 0; i < sessionPool[client_ticket].getJobCount(); i++) {
		JobTracker tracker = sessionPool[client_ticket].getJobTrackerAt(i);
		if (tracker.getStatus() == JobStatus::PAUSED) {
			pbs_sigjob(tracker.getConnection(), 
					const_cast<char*>(tracker.getId().c_str()), 
					const_cast<char *>(sig.c_str()), 0);
		}		
		else {
			cout << "job " << tracker.getUserJob().id << " hasn't been suspended!" << endl;
		}
	}
	cout << "resume_flow" << endl;
}

void HpgcJobHandler::cancel(const int32_t client_ticket) {
	for (int i = 0; i < sessionPool[client_ticket].getJobCount(); i++) {	
		JobTracker tracker = sessionPool[client_ticket].getJobTrackerAt(i);
		if (tracker.getStatus() != JobStatus::RUNNING && tracker.getStatus() != JobStatus::FAILED ) {
			pbs_deljob(tracker.getConnection(), 
					const_cast<char*>((tracker.getId()).c_str()), 0);
		}
		else {
			cout << "job " << tracker.getUserJob().id << " has done!" << endl;
		}
	}
	cout << "cancel_flow" << endl;
}

void HpgcJobHandler::get_status(Result& _return, const int32_t client_ticket) {
	cout << "get job flow status..." << endl;
	if (sessionPool.count(client_ticket) == 0) {
		_return.flow_status = Status::NOT_EXIST;
		_return.message = "get status error, job id not exist";
		cout << "get status error, job id not exist" << endl;
	}
	else {
		_return.flow_status = Status::FINISHED;
		_return.message = "";

		cout << "the job status is: " << _return.flow_status << endl;
		cout << "The result sent to client is:" << endl;

		for (int i = 0; i < sessionPool[client_ticket].getJobCount(); i++) {
			JobTracker tracker = sessionPool[client_ticket].getJobTrackerAt(i);
			JobResult jr;
			jr.message = tracker.getResult();
			jr.status = tracker.getStatus();
			if (jr.status == JobStatus::FAILED) {
				_return.flow_status = Status::FAILED;
			}	
			if (jr.status != JobStatus::FAILED && jr.status != JobStatus::FINISHED) {
				_return.flow_status = Status::RUNNING;
			}
			_return.job_result_list.push_back(jr);
			// log and print
			Logger::log(LOG_FILE, INFO, APPLICATION, jr.message);	
			cout << jr.message << endl;
		}

		if (_return.flow_status == Status::FAILED || _return.flow_status == Status::FINISHED ) {
			sessionPool[client_ticket].setAvailable(true);
			sessionPool[client_ticket].finalize();
		}

		//	cout<<"HPGC flow finished."<<endl;
		//	!!!! the finalize of the current active session should not be placed only here
		//	it should be invoked when the job or jobflow is really finished. !!!!
		//	by Liu Lu
		//	2012/3/19
	}
	//  pthread_cond_destroy(&waitingCond);
}

