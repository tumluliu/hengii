/*
 * =====================================================================================
 *
 *       Filename:  hpgcjobhandler.cpp
 *
 *    Description:  The class skeleton is generated by thrift compiler. All the service
 *  			  	interface are implemented here.
 *
 *        Version:  1.0
 *        Created:  2012年03月23日 11时47分00秒
 *       Revision:  none
 *       Compiler:  gcc
 *
 *         Author:  Liu Lu(), nudtlliu@gmail.com
 *                  YANG Anran(), 08to09@gmail.com
 *   Organization:  
 *
 * =====================================================================================
 */

#include <iostream>

#include "hpgcjobhandler.h"
#include "flowruntime.h"
#include "jobruntime.h"
#include "log.h"
#include "dbjobrepo.h"
#include "mysqldb.h"
#include "torquejobfactory.h"
#include "filemetarepo.h"
#include "optionvalidator.h"
#include "programvalidator.h"
#include "dbdatarepo.h"

using hpgc::higis::interface::JobFlow;
using hpgc::higis::interface::Job;
using hpgc::higis::interface::Result;
using hpgc::higis::interface::JobResult;

HpgcJobHandler::HpgcJobHandler() : db_(new MySqlDb), repo_(new DbJobRepo(*db_)),
	datarepo_(new DbDataRepo(*db_)), center_(new TrackerCenter(*repo_)) {
	}

int64_t HpgcJobHandler::start_single_job(const Job& job, const std::string& user_id) {
	JobFlow flow;
	flow.job_count = 1;
	flow.jobs.push_back(job);
	return start(flow, user_id); 
}

int64_t HpgcJobHandler::start(const JobFlow& flow, const std::string& user_id) {
	std::cout << "Start processing job flow" << std::endl;
	std::cout << "number of jobs in this flow: " << flow.job_count << std::endl;

	FileMetaRepo metarepo;

	std::shared_ptr<JobValidator> substage2(new OptionValidator(
				std::shared_ptr<JobValidator>(), metarepo));
	ProgramValidator substage1(substage2, metarepo);
	Validator guard(substage1);

	TorqueJobFactory batchfactory;
	TrackerFactory man(flow, user_id, *repo_, batchfactory, guard, metarepo, *datarepo_);

	int64_t id = repo_->RegisterJobFlow(flow, user_id);
	if (id > 0) {
		std::shared_ptr<Tracker> car(man.Create(id));
		if (car != NULL){
			center_->LoadTracker(car);
		}
	}

	return id;
}

void HpgcJobHandler::pause(const int64_t client_ticket) {
	Log().Info() << "trying to pause " << client_ticket; 
}

void HpgcJobHandler::resume(const int64_t client_ticket) {
	Log().Info() << "trying to resume " << client_ticket;
}

void HpgcJobHandler::cancel(const int64_t client_ticket) {
	if (repo_->IfFlowExists(client_ticket)) {
		center_->CancelTracker(client_ticket);
	}
	else {
		Log().Error() << "cancel tracker error, id " << client_ticket << " not exist";
	}
}

void HpgcJobHandler::get_status(Result& _return, const int64_t client_ticket) {
	std::unique_ptr<FlowRuntime> state = 
		repo_->CreateFlowRuntime(client_ticket);
	if (state == NULL) {
		_return.flow_status = hpgc::higis::interface::Status::NOT_EXIST;
		_return.message = "get status error, job flow id not exist";
		Log().Error() << _return.message;
	}
	else {
		_return.flow_status 
			= static_cast<hpgc::higis::interface::Status::type>(state->get_status());
		_return.message = state->get_message();
		for (int i = 0; i < state->get_jobcount(); i++) {
			std::shared_ptr<JobRuntime> jobstate(state->get_jobruntime(i));
			JobResult jobpart;
			jobpart.status
				= static_cast<hpgc::higis::interface::JobStatus::type>(
						jobstate->get_status());
			jobpart.message = jobstate->get_message();
			_return.job_result_list.push_back(jobpart);
		}
	}

	/* The log is toooo verbose without this condition */
	if (_return.message != "") {
		Log().Debug() << "The result sent to client is: " << _return.message;
	}
}
