/*
 * =====================================================================================
 *
 *       Filename:  hpgcjobhandler.cpp
 *
 *    Description:  The class skeleton is generated by thrift compiler. All the service
 *  			  	interface are implemented here.
 *
 *        Version:  1.0
 *        Created:  2012年03月23日 11时47分00秒
 *       Revision:  none
 *       Compiler:  gcc
 *
 *         Author:  Liu Lu(), nudtlliu@gmail.com
 *                  YANG Anran(), 08to09@gmail.com
 *   Organization:  
 *
 * =====================================================================================
 */

#include <iostream>

#include "hpgcjobhandler.h"
#include "flowruntime.h"
#include "jobruntime.h"
#include "log.h"
#include "jobrepoentry.h"

using hpgc::higis::interface::JobFlow;
using hpgc::higis::interface::Job;
using hpgc::higis::interface::Result;
using hpgc::higis::interface::JobResult;

HpgcJobHandler::HpgcJobHandler() : managers_(), trackers_(), lock_() {
	pthread_mutex_init(&lock_, NULL);
}

HpgcJobHandler::~HpgcJobHandler() {
	pthread_mutex_destroy(&lock_);
	JobRepoEntry::Close();
}

int64_t HpgcJobHandler::start_single_job(const Job& job, const std::string& user_id) {
	JobFlow flow;
	flow.job_count = 1;
	flow.jobs.push_back(job);
	return start(flow, user_id); 
}

int64_t HpgcJobHandler::start(const JobFlow& flow, const std::string& user_id) {
	std::cout << "Start processing " << PROJECT_NAME << " job flow" << std::endl;
	std::cout << "number of jobs in this flow: " << flow.job_count << std::endl;

	int64_t id = -1;
	TrackerOwner *man = new TrackerOwner(flow, user_id);
	Tracker *car = man->Borrow(id);
	if (car == NULL) {
		if (id < 0) {
			Log().Error() << "Cannot generate proper ticket";
		}
		else {
			Log().Error() << "There is some error when generate tracker "
				<< id;
		}
		delete man;
	}
	else {

		pthread_mutex_lock(&lock_);

		managers_.insert(
				std::pair<int64_t, TrackerOwner*>(id, man));
		trackers_.insert(
				std::pair<int64_t, Tracker*>(id, car));
		car->add_recorder(this);

		Log().Debug() << "[MsgFlow] Start flow " << id;
		car->GoPlay();

		pthread_mutex_unlock(&lock_);
	}

	return id;
}

void HpgcJobHandler::pause(const int64_t client_ticket) {
	Log().Info() << "trying to pause " << client_ticket; 
}

void HpgcJobHandler::resume(const int64_t client_ticket) {
	Log().Info() << "trying to resume " << client_ticket;
}

void HpgcJobHandler::cancel(const int64_t client_ticket) {
	Log().Info() << "trying to cancel " << client_ticket;
}

void HpgcJobHandler::get_status(Result& _return, const int64_t client_ticket) {
	FlowRuntime *state = JobRepoEntry::Open()->BorrowJobFlowRuntime(client_ticket);
	if (state == NULL) {
		_return.flow_status = hpgc::higis::interface::Status::NOT_EXIST;
		_return.message = "get status error, job flow id not exist";
		Log().Error() << _return.message;
	}
	else {
		_return.flow_status 
			= static_cast<hpgc::higis::interface::Status::type>(state->get_status());
		_return.message = state->get_message();
		for (int i = 0; i < state->get_jobcount(); i++) {
			JobRuntime *jobstate = state->get_jobruntime(i);
			JobResult jobpart;
			jobpart.status
				= static_cast<hpgc::higis::interface::JobStatus::type>(
						jobstate->get_status());
			jobpart.message = jobstate->get_message();
			_return.job_result_list.push_back(jobpart);
		}
		JobRepoEntry::Open()->ReturnJobFlowRuntime(state);
	}

	Log().Debug() << "The result sent to client is: " << _return.message;
}

void HpgcJobHandler::OnePlayerDone(int64_t id) {
	Log().Debug() << "[MsgFlow] Flow " << id << " complete";
	managers_[id]->Return(trackers_[id]);

	delete managers_[id];
	Log().Debug() << "[MsgFlow] Flow " << id << " die";

	pthread_mutex_lock(&lock_);
	managers_.erase(id);
	trackers_.erase(id);
	pthread_mutex_unlock(&lock_);
}
